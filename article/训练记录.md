# 训练记录

现在训练频率跟高中时期不能比了，~~所以不按月份分了~~，一大段时间的全写在一篇里。

# 大二 9 月份

## Codeforces2063F Counting is Not Fun

TAGS：括号树，卡特兰数

容易发现每次加一对互相匹配的括号的过程相当于将原序列划分为多个各自独立的括号序列。对于一对互相匹配的括号`(..(..)..)`其内部可能有其他已加入的互相匹配的括号，那么可以递归的去算，然后再考虑那些其他没有被覆盖的点。为了说明这个过程，我们建立一个括号树，每个点 $(l,r)$ 表达一对相互匹配的括号，直接向其内部下一级的括号对连边。然后我们考虑计算一个点 $(l,r)$ 子树内的答案，首先儿子节点之间是相互独立的，他们的方案数可以直接乘起来。对于 $(l,r)$ 内尚未被儿子节点覆盖的位置，只要将儿子节点代表的合法括号序列全部删除后，形成一个合法的括号序列即可。那这个部分的贡献相当于就是 $Catlan_{r-l-1-\sum\limits_{j\in son}(r_j-l_j+1)}$，也可以乘进总方案里。

暴力的做法可以直接把这颗树建出来，容易发现的是最终答案就是每个点的 $Catlan_{r-l-1-\sum\limits_{j\in son}(r_j-l_j+1)}$ 之乘积。现在考虑怎么维护这颗树以及答案。

每次加入一对括号时，我们需要在树上先找到这对括号的父亲即上一层括号，用线段树维护并在线段树上二分即可。

然后这个点会插入，作为刚刚找到的父亲节点的儿子，并继承父亲节点的一部分儿子。容易发现这个过程里只会改变父亲节点，以及新统计自己的贡献，那么我们要考虑的就是如何快速计算一个点的贡献。

用线段树维护序列中每个点所在括号序列的深度，每次加入一对括号 $(l,r)$ 将 $dep_{[l,r]}$ 做一个区间加。那么我们便可以知道序列中每个数所在括号序列树中的深度。树上一个点的 $r-l-1-\sum\limits_{j\in son}(r_j-l_j+1)$ 其实只需要求一个区间最小值个数就可以了。

**聪明做法**：考虑倒过来整个过程，加点变成删点。我们需要统计的信息相当于是一个 “儿子的权值之和”。用一个并查集维护即可，每次删掉一个点就直接把这个点与其并查集上的父亲合并，并将自己“儿子权值之和”加过去。明显好做了很多。

## 2025ICPC网络赛2 K The Only Heart

TAGS：树的重心，树上背包

极其重要的性质：树存在两个重心 $x,y$ 的充分必要条件是将 $(x,y)$ 断开后两边联通块大小相等。具体证明可以手玩一下从重心 $x$ 走到重心 $y$ 的过程。

然后答案等于总联通块数 - 存在两个重心的联通块数。

对于总联通块数的计算，我们在每个联通块的深度最浅点处统计其贡献，那么便可以树上背包，设 $f_{x,i}$ 表示以 $x$ 为根的子树内包含 $x$ 的大小为 $i$ 的联通块数。

对于存在两个重心的联通块，其等价于将 $(x,y)$ 这条边子树内的点的点权设为 $1$，子树外的点权设为 $-1$，最终点权之和为 $0$。那么我们 DP 去算选出 **一个能够将某个子树点权设为 $1$ 其他全部设为 $-1$ 后权值和为 $0$ 的联通块**  数量。设 $g_{x,i}$ 表示以 $x$ 为根，且子树内的某个子树被全部设为 $1$（其他为 $-1$），点权和为 $i$ 的联通块数量（同一个联通块可能由于染色情况不一样而变得有区别）。

## 2025ICPC网络赛1 C Canvas Painting

TAGS：贪心

每次操作可以看成是把一个单点与一个联通块直接连边（把单点的颜色变为联通块的颜色），那么一个点的颜色显然最多只会变换一次。那么对于一个合法的最优操作序列，我们构造方案为将右边点的颜色变为左边点的颜色显然能够满足这个要求。有了以上观察，一个显然的策略是从左到右尝试将每个单点进行一次染色，至于染成什么颜色不重要，只要知道这次操作让总颜色数-1就行了。那么每次尝试对一个点进行染色的时候使用一个右端点最小的区间便是一个显然的贪心策略。

## 2025牛客多校9G Permutation

TAGS：笛卡尔树

这个结构明显用笛卡尔树来研究比较好（考场上忘记笛卡尔树了，看了题解觉得真tm有道理）。

建出笛卡尔树后观察，如果一个数要出现在结果里，之前起码将其子树外的所有点删除。在确定了结果序列的最后一个数后，剩下的可能出现的数都是最后一个数在笛卡尔树上的祖先。此时相当于有一个至少删除数，大于这个删除次数的删除操作就删最后一个数的子树里的点，确定了删除次数后查询次数也是固定的。发现在祖先任意位置查询都没有限制，于是便可以组合数计算。

## Codeforces2140E Prime Gaming

TAGS：DP，计数

其实根本不需要分析最优博弈策略是什么，直接 DP 就行，还是题做少了。

先考虑值域为 2 的情况，发现可以直接状压 DP。这个就是 easy version，其实为后面的 hard version 提供了提示。

考虑经典"大值域 -> 0/1"手法：$\sum cnt_x*x=\sum cnt_x\sum\limits_{i=1}^n [i\leq x]=\sum\limits_{i=1}^n \sum\limits_{x \geq i}^n cnt_x $。可以看成枚举 $i$ 后，

## Codeforces2138C Maple and Tree Beauty

TAGS：背包，根号分治

考虑最优策略一定是把同一深度的结点填成一个颜色，那么首先答案不会超过最浅叶子的深度。然后问题相当于转化为了一个背包问题，同一层深度的节点数量相当于一个物品的体积。再进一步分析性质，首先可以发现如果直接按照 BFS 序先刷白再刷黑，答案至少都能达到最浅叶子的深度减 1，那么只需要判断能否达到最大答案即可。能够达到最大答案只需要判断能否选出一种合法的背包方案，即白色和黑色都没有超过使用限制，可以使用 `std::bitset<N>` 来优化背包 DP。复杂度为 $\mathcal O(\frac{n^2}{\omega})$。

进一步的优化：因为物品总体积有上限，考虑根号分治，体积大于根号的物品不会超过根号个，这部分只会做根号轮 DP。对于体积小于根号的物品们，瓶颈在于每种固定体积的物品的数量比较多，考虑对这部分物品进行二进制分组，通过神秘的分析，这样子处理完后物品总数量是 $\mathcal O(\sqrt{n})$ 的，复杂度进一步优化。

再更一步：考虑生成函数，这种总体积有限制的背包问题可以通过 huffman 树的方法去合并起来。也可以直接去通过 ln exp 分析，复杂度更小。

# 大一暑假

 ## Codeforces2063E Triangle Tree

TAGS：树上启发式合并

其实是有线性做法的，就当复习一下算法了。

树上启发式合并：在树上每个节点都将其所有轻子树结点都访问一遍的总时间复杂度是 $\mathcal O(n \log n)$ 的。在计算树上点对问题的时候，一般留着重子树去最后访问，并将重子树信息的数据结构进行保留（前面轻子树的都删除了）。然后遍历一遍所有轻子树结点，去计算点对贡献。

# 大一

太tm摆了。。。

## Codeforces2114F Small Operatiosn

TAGS：约数理论

需要知道的结论：$\max\limits_{i=1}^n \{D(i)\}\approx\mathcal O(n^{\frac{1}{3}})$。那么就可以暴力 DP 了。

## Codeforces888G Xor-MST

TAGS：最小生成树，01-Trie

Boruvka：做法比较显然，我们只需要搞一个支持插入删除的 01-Trie 来每次为每个点寻找最小连边。

Kruskal：其实本质上还是最小生成树的贪心思想。我们知道最小生成树本质上是个贪心，只要先加入边权较小的边即可保证正确性。那么我们将问题放在 01-Trie 上思考。然后可以发现，贪心的过程在 01-Trie 上的体现过程就是先会把子树内的点连成一个联通块，再连子树与子树间的边，再迭代上去。

需要知道一个 01-Trie 的性质：01-Trie 的叶子节点的中序遍历就是原数列排好序的结果，因此我们只需要一开始将原序列排序，01-Trie 上一个结点子树内的数便是一个连续的区间，可以简化实现过程。

## Codeforces2045H Missing Seperators

TAGS：DP 优化，卡常

数据范围暗示的很明显，我们考虑 $n^2$ DP。

直接设 $f(l,r)$ 表示最后一段取 $S[l...r]$ 时的最大划分，考虑优化转移。

容易发现若 $f(l,r)$ 能更新到 $f(r+1,k)$，则 $f(r+1,k+1),f(r+1,k+2),\cdots$ 也能被更新到。那么转移的时候只需要转移到最小的 $k$，然后计算一下前缀最大值。

需要注意的是 $\mathcal O(n^2)$ 的数组寻址很慢，需要卡常。为了减少寻址次数，我们可以将 DP 值与转移方案存在一个 `std::pair<int, int>`里，这样子寻址次数就相比开两个数组少了一半。

## Codeforces2045I Microwavable Subsequence

TAGS：数颜色，计数，观察

一开始想的是以贪心匹配的方式去算 $f$，但这当时没想到怎么用来计数。

仔细分析一下，把贡献放在匹配上的那个点 $i$ 上，条件写出来就是 $lst_{a_i}$ 到 $i$ 中间有一个另外的颜色。

然后问题就转化为数一段区间内的颜色个数，扫描线+树状数组解决。

## Codeforces2045B ICPC Square

TAGS：整除分块

首先需要观察到一个比较显然的事实：每次增加的数是一定上升的。那么只需要考虑最后一次增加的数不超过限制即可。

设第 $k$ 次倍数为 $a_k$，我们需要最大化 $\prod\limits_{i=1}^k a_i$，同时需要满足 $S\cdot\prod\limits_{i=1}^k a_i \cdot \frac{a_k-1}{a_k} \leq D,S\cdot \prod\limits_{i=1}^k a_i \leq n$，同时我们需要保证 $a_k|\prod\limits_{i=1}^k a_i$，那么在确定 $a_k$ 时，通过第一个条件我们得到 $\prod \leq \lfloor\frac{Da_k}{S(a_k-1)}\rfloor$，要求 $\leq t$ 的最小的 $b$ 的倍数即 $\lfloor\frac{t}{b}\rfloor b$，又通过 $\lfloor\frac{\lfloor\frac{n}{a}\rfloor}{b}\rfloor=\lfloor\frac{n}{ab}\rfloor$，我们可以得到最大符合条件的 $\prod$ 为 $\lfloor\frac{\lfloor\frac{D}{S}\rfloor}{a_k-1} \rfloor \cdot a_k$。如果考虑第二个条件，则是 $\lfloor\frac{\lfloor\frac{n}{S}\rfloor}{a_k}\rfloor \cdot a_k$，那么对于一个固定的 $a_k$，我们则需要从 $\lfloor\frac{\lfloor\frac{D}{S}\rfloor}{a_k-1}\rfloor$ 与 $\lfloor\frac{\lfloor\frac{n}{S}\rfloor}{a_k}\rfloor$ 中选一个较小的来乘上 $a_k$ 来参加答案的更新。可以发现这里就是双整除分块的形式了。

其实更好的思路是一开始就把 $n,D$ 整除 $S$，分析起来会更加简单。

## Codeforces2041M

TAGS：双指针

答案只有这几种形式：只排序一个前缀，只排序一个后缀，排序一对不交叉的前缀与后缀，排序一对交叉的前缀与后缀。

前三种其实没有太大区别，可以认为一定是先找到一个极大的连续已经**归位**的子串，然后对两边的前缀与后缀进行排序。

然后讨论第三种，为了方便只讨论先排序前缀的情况，枚举这个前缀后只需要算出极大**归位**前缀即可。

## Codeforces2041C

TAGS：状压 DP，状态优化

观察数据范围肯定是比较暴力的，但是阶乘级又不太现实，考虑指数级。

容易想到的暴力做法是设 $f(i,S_1,S_2)$ 表示考虑了$x\in[1,i]$ 的点后，选了的 $y,z$ 坐标分别构成集合 $S_1,S_2$ 的最小值。

但是仔细分析一下，总状态数是 $\sum\limits_{i=1}^n \binom{n}{i}\binom{n}{i}\approx\sum\limits_{i=0}^n \binom{n}{i}\binom{n}{i}=\sum\limits_{i=0}^n \binom{n}{i}\binom{n}{n-i}=\binom{2n}{n}$ 的，还是比 $4^n$ 小了不少（虽然量级没变），对于每个状态转移的复杂度是 $\mathcal O(n)$，因此总复杂度是 $\mathcal O(n\binom{2n}{n})$。

## Codeforces2039E 

TAGS：计数，递推

VP 的时候思路实在不太清晰，其实是不难的，可能还需要更多训练使得思路整理的更快。

首先要意识到有一类比较优秀的序列：逆序对数大于目前序列中所有数的序列。这种序列可以进行一步操作，插入新数字到除了末尾以外的所有位置，得到新的数列还能保持这个性质。

这启发我们进行**部分** DP：设 $f_i$ 表示长度为 $i$ 的具有上述性质的序列个数。除了 $f_i$ 中的序列，我们还要考虑逆序对为0，1的，以及末尾连了连续个最大值的序列。转移的时候分别考虑这几类不同的序列对 $f_i$ 的影响。

- 优秀序列到优秀序列，$\sum\limits_{j<i} jf_j$。
- 逆序对为 1 的序列到优秀序列，逆序对为 1 的序列一定是形如 `000...00010111...1` 的形式，只要再填一个 1 到第一个 1 前面的任意位置即可。前缀 $0$ 的个数为 $j$，有 $j \leq i - 3$，每个 $j$ 的贡献为 $j+1$，总贡献为 $\frac{i(i-3)}{2}$。

最后计算长度为 $i$ 的总答案时，先考虑 $j<i$ 的 $f_j$ 的贡献，显然唯一方案是往后面填 $j-i$ 个数，然后再计算一下逆序对为0，1的序列的个数。

## Codeforces2046C

TAGS：二分答案

离散化后只需要考虑出现过的坐标。套个二分答案后就扫一遍就行。