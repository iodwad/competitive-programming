## 离散化

```cpp
void discre(int *a, int len) { // 数组从 1 开始编号，长度为 len
  static vector<int> num; num.clear();
  for (int i = 1; i <= len; ++i) num.push_back(a[i]);
  sort(num.begin(), num.end()); 
  num.erase(unique(num.begin(), num.end()), num.end());
  for (int i = 1; i <= len; ++i) a[i] = lower_bound(num.begin(), num.end(), a[i]) - num.begin();
}
```

## 模运算类

```cpp
const int MOD = ;
int mul(int x) { return x; }
int add(int x) { return x; }
template<class... A> int mul(int x, A... y) { return (i64)x * mul(y...) % MOD; }
template<class... A> int add(int x, A... y) { return (x += add(y...)) >= MOD ? x - MOD : x; }
template<class... A> int sub(int x, A... y) { return (x -= add(y...)) < 0 ? x + MOD : x; }
int fpow(int x, int y) {
  int res = 1;
  for (int i = x; y; y >>= 1, i = mul(i, i))
    if (y & 1) res = mul(res, i);
  return res;
}
// add(x, y, z, ...);
// mul(x, y, z, ...);
```

## 树上背包

### 加法类卷积

默认背包大小为 0 的时候没有意义

 ```cpp
 f[x][1] = value; // 初始背包只有一个元素，就是 x 自身的权值
 void add_merge(int *res, int *f, int *g, int n, int m) {
   for (int i = n; i >= 1; --i) 
     for (int j = m; j >= 1; --j) 
       res[i + j] = add(res[i + j], mul(f[i], g[j]));
 }
 add_merge(f[x], f[x], f[to], siz[x], siz[to]); siz[x] += siz[to];
 ```

### 减法类卷积

```cpp
void sub_merge(int *res, int *f, int *g, int n, int m) {
  for (int i = 1; i <= n; ++i) 
    for (int j = 1; j <= min(i, m); ++j) 
      res[i - j] = add(res[i - j], mul(f[i], g[j]));
}
sub_merge(g[x], g[x], f[to], siz[x], siz[to]); siz[x] += siz[to];
```

