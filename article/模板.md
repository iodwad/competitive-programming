## 最大流

```cpp
namespace Flow {
  const int maxn = ;
  const int maxm = ;
  struct Edge {
    int edge;
    int fst[maxn + 5], to[maxm + 5], f[maxm * 2 + 5], nxt[maxm * 2 + 5];
    Edge() {
      edge = -1;
      memset(fst, -1, sizeof(fst));
      memset(nxt, -1, sizeof(nxt));
    }
    void _add(int u, int v, int _f) {
      ++edge;
      to[edge] = v; f[edge] = _f;
      nxt[edge] = fst[u]; fst[u] = edge;
    }
    void add(int u, int v, int f) {
      _add(u, v, f);
      _add(v, u, 0);
    }
  } e;
  int S, T, cure[maxn + 5], dep[maxn + 5];
  bool bfs() {
    static queue<int> q;
    memset(dep, 0, sizeof(dep));
    q.push(S); dep[S] = 1;
    while (!q.empty()) {
      int u = q.front(); q.pop();
      for (int k = e.fst[u]; ~k; k = e.nxt[k]) {
        int to = e.to[k], f = e.f[k];
        if (f > 0 && !dep[to]) {
          dep[to] = dep[u] + 1;
          q.push(to);
        }
      }
    }
    return dep[T] != 0;
  }
  int Augment(int x, int flow) {
    if (x == T) return flow;
    int rest = flow;
    for (int &k = cure[x]; ~k && flow; k = e.nxt[k]) {
      int to = e.to[k], f = e.f[k];
      if (f > 0 && dep[to] == dep[x] + 1) {
        int tmp = Augment(to, min(rest, f));
        if (!tmp) dep[to] = -1;
        e.f[k] -= tmp;
        e.f[k ^ 1] += tmp;
        rest -= tmp;
      }
    }
    return flow - rest;
  }
  int Dinic() {
    int res = 0;
    while (bfs()) {
      memcpy(cure, e.fst, sizeof(cure));
      int tmp = 0;
      while ((tmp = Augment(S, 1e18))) res += tmp;
    }
    return res;
  }
}

using namespace Flow;
```

## 离散化

```cpp
void discre(int *a, int len) { // 数组从 1 开始编号，长度为 len
  static vector<int> num; num.clear();
  for (int i = 1; i <= len; ++i) num.push_back(a[i]);
  sort(num.begin(), num.end()); 
  num.erase(unique(num.begin(), num.end()), num.end());
  for (int i = 1; i <= len; ++i) a[i] = lower_bound(num.begin(), num.end(), a[i]) - num.begin();
}
```

## 模运算类

```cpp
const int MOD = ;
int mul(int x) { return x; }
int add(int x) { return x; }
template<class... A> int mul(int x, A... y) { return (i64)x * mul(y...) % MOD; }
template<class... A> int add(int x, A... y) { return (x += add(y...)) >= MOD ? x - MOD : x; }
template<class... A> int sub(int x, A... y) { return (x -= add(y...)) < 0 ? x + MOD : x; }
int fpow(int x, int y) {
  int res = 1;
  for (int i = x; y; y >>= 1, i = mul(i, i))
    if (y & 1) res = mul(res, i);
  return res;
}
// add(x, y, z, ...);
// mul(x, y, z, ...);
```

## 树上背包

### 加法类卷积

默认背包大小为 0 的时候没有意义

 ```cpp
 f[x][1] = value; // 初始背包只有一个元素，就是 x 自身的权值
 void add_merge(int *res, int *f, int *g, int n, int m) {
   for (int i = n; i >= 1; --i) 
     for (int j = m; j >= 1; --j) 
       res[i + j] = add(res[i + j], mul(f[i], g[j]));
 }
 add_merge(f[x], f[x], f[to], siz[x], siz[to]); siz[x] += siz[to];
 ```

### 减法类卷积

```cpp
void sub_merge(int *res, int *f, int *g, int n, int m) {
  for (int i = 1; i <= n; ++i) 
    for (int j = 1; j <= min(i, m); ++j) 
      res[i - j] = add(res[i - j], mul(f[i], g[j]));
}
sub_merge(g[x], g[x], f[to], siz[x], siz[to]); siz[x] += siz[to];
```

